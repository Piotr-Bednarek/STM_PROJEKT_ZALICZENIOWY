#include "vl53l0x.h"

// Basic Registers
#define VL53L0X_REG_IDENTIFICATION_MODEL_ID         0xC0
#define VL53L0X_REG_SYSRANGE_START                  0x00
#define VL53L0X_REG_RESULT_INTERRUPT_STATUS         0x13
#define VL53L0X_REG_RESULT_RANGE_STATUS             0x14

// Helpers
static void WriteByte(VL53L0X_Dev_t *dev, uint8_t reg, uint8_t val) {
    HAL_I2C_Mem_Write(dev->hi2c, dev->address, reg, I2C_MEMADD_SIZE_8BIT, &val, 1, 100);
}

static uint8_t ReadByte(VL53L0X_Dev_t *dev, uint8_t reg) {
    uint8_t val = 0;
    HAL_I2C_Mem_Read(dev->hi2c, dev->address, reg, I2C_MEMADD_SIZE_8BIT, &val, 1, 100);
    return val;
}

static void WriteMulti(VL53L0X_Dev_t *dev, uint8_t reg, uint8_t *data, uint16_t size) {
	HAL_I2C_Mem_Write(dev->hi2c, dev->address, reg, I2C_MEMADD_SIZE_8BIT, data, size, 100);
}

// Default tuning settings from standard driver
uint8_t vl53l0x_tuning[] = {
  0xFF, 0x01, 0x00, 0x00, 0xFF, 0x00, 0x09, 0x00, 0x10, 0x00, 0x11, 0x00, 0x24, 0x01, 0x25, 0xFF,
  0x75, 0x00, 0xFF, 0x01, 0x4E, 0x2C, 0x48, 0x00, 0x30, 0x20, 0xFF, 0x00, 0x30, 0x09, 0x54, 0x00,
  0x31, 0x04, 0x32, 0x03, 0x40, 0x83, 0x46, 0x25, 0x60, 0x00, 0x27, 0x00, 0x50, 0x06, 0x51, 0x00,
  0x52, 0x96, 0x56, 0x08, 0x57, 0x30, 0x61, 0x00, 0x62, 0x00, 0x64, 0x00, 0x65, 0x00, 0x66, 0xA0,
  0xFF, 0x01, 0x22, 0x32, 0x47, 0x14, 0x49, 0xFF, 0x4A, 0x00, 0xFF, 0x00, 0x7A, 0x0A, 0x7B, 0x00,
  0x78, 0x21, 0xFF, 0x01, 0x23, 0x34, 0x42, 0x00, 0x44, 0xFF, 0x45, 0x26, 0x46, 0x05, 0x40, 0x40,
  0x0E, 0x06, 0x20, 0x1A, 0x43, 0x40, 0xFF, 0x00, 0x34, 0x03, 0x35, 0x44, 0xFF, 0x01, 0x31, 0x04,
  0x4B, 0x09, 0x4C, 0x05, 0x4D, 0x04, 0xFF, 0x00, 0x44, 0x00, 0x45, 0x20, 0x47, 0x08, 0x48, 0x28,
  0x67, 0x00, 0x70, 0x04, 0x71, 0x01, 0x72, 0xFE, 0x76, 0x00, 0x77, 0x00, 0xFF, 0x01, 0x0D, 0x01,
  0xFF, 0x00, 0x80, 0x01, 0x01, 0xF8, 0xFF, 0x01, 0x8E, 0x01, 0x00, 0x01, 0xFF, 0x00, 0x80, 0x00
};

static void VL53L0X_LoadTuning(VL53L0X_Dev_t *dev) {
	for(int i = 0; i < sizeof(vl53l0x_tuning); i+=2) {
		WriteByte(dev, vl53l0x_tuning[i], vl53l0x_tuning[i+1]);
	}
}

uint8_t VL53L0X_Init(VL53L0X_Dev_t *dev, I2C_HandleTypeDef *hi2c) {
    dev->hi2c = hi2c;
    dev->address = VL53L0X_ADDR; // 0x52
    dev->offset_mm = 0;

    // Check ID
    uint8_t model_id = ReadByte(dev, VL53L0X_REG_IDENTIFICATION_MODEL_ID);
    if (model_id != 0xEE) {
        return 0; // Device not found or ID mismatch
    }

    // Data Init
    WriteByte(dev, 0x88, 0x00);
    WriteByte(dev, 0x80, 0x01);
    WriteByte(dev, 0xFF, 0x01);
    WriteByte(dev, 0x00, 0x00);
    
    uint8_t stop_var = ReadByte(dev, 0x91); // Read stop variable
    
    WriteByte(dev, 0x00, 0x01);
    WriteByte(dev, 0xFF, 0x00);
    WriteByte(dev, 0x80, 0x00);

    // Load Tuning Settings
    VL53L0X_LoadTuning(dev);

    // Set interrupt config to new sample ready
    WriteByte(dev, 0x0A, 0x04); // SYSTEM_INTERRUPT_CONFIG_GPIO set to NEW_SAMPLE_READY
    
    // Set Measurement Timing Budget (simplified)
    WriteByte(dev, 0xFF, 0x01);
    WriteByte(dev, 0x00, 0x00);
    WriteByte(dev, 0xFF, 0x01);
    WriteByte(dev, 0x00, 0x00);
    WriteByte(dev, 0xFF, 0x00);

    return 1;
}

void VL53L0X_SetOffset(VL53L0X_Dev_t *dev, int16_t offset) {
    dev->offset_mm = offset;
}

uint16_t VL53L0X_ReadDistance(VL53L0X_Dev_t *dev) {
    // Write 0x01 to REG 0x00 to successfully start Single Shot
    WriteByte(dev, 0x80, 0x01);
    WriteByte(dev, 0xFF, 0x01);
    WriteByte(dev, 0x00, 0x00);
    WriteByte(dev, 0x91, 0x3C); // Legacy stop variable
    WriteByte(dev, 0x00, 0x01);
    WriteByte(dev, 0xFF, 0x00);
    WriteByte(dev, 0x80, 0x00);

    WriteByte(dev, VL53L0X_REG_SYSRANGE_START, 0x01);

    // Wait for completion
    uint8_t cnt = 0;
    uint32_t start = HAL_GetTick();
    while (1) {
    	uint8_t val = ReadByte(dev, VL53L0X_REG_RESULT_INTERRUPT_STATUS);
        if (val & 0x07) break; // Data ready
        
        if (HAL_GetTick() - start > 1000) {
        	return 0xFFFF; // Timeout 1s
        }
    }

    // Read distance
    // 0x1E corresponds to RESULT_RANGE_STATUS + 10
    uint8_t high = ReadByte(dev, 0x1E);
    uint8_t low = ReadByte(dev, 0x1F);
    uint16_t dist = (high << 8) | low;

    if (dist != 0xFFFF) {
        dist = (uint16_t)((int16_t)dist + dev->offset_mm);
    }

    // Clear Interrupt
    WriteByte(dev, 0x0B, 0x01); 

    return dist;
}
